name: Deploy Vault to Digital Ocean

on:
  push:
    branches:
      - main
  workflow_run:
    workflows: ["Build and Push Vault Docker Image"]
    types:
      - completed
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest   
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Copy files to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DROPLET_IP }}
          username: deployuser
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          source: "docker-compose.vault.yml"
          target: "/home/deployuser"

      - name: Deploy Vault container
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DROPLET_IP }}
          username: deployuser
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            cd /home/deployuser

            # Create the external Docker network if not already created
            docker network create app-network || true
            
            # Pull fresh images
            docker compose -f docker-compose.vault.yml pull
            
            # Start services
            docker compose -f docker-compose.vault.yml up -d

      - name: Check Vault Status and Initialize if needed
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DROPLET_IP }}
          username: deployuser
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            # Wait for Vault to be ready
            echo "Waiting for Vault to start..."
            sleep 10
            
            # Check if Vault is initialized
            INIT_STATUS=$(docker exec $(docker ps -q -f name=vault) vault status -format=json | jq -r .initialized)
            
            if [ "$INIT_STATUS" = "false" ]; then
              echo "Vault is not initialized. Initializing now..."
              # Initialize Vault and save output
              INIT_OUTPUT=$(docker exec $(docker ps -q -f name=vault) vault operator init)
              
              # Create secure credentials directory if it doesn't exist
              CREDS_DIR="/home/deployuser/.vault"
              mkdir -p "$CREDS_DIR"
              chmod 700 "$CREDS_DIR"
              
              # Save credentials with fixed name
              CREDS_FILE="$CREDS_DIR/vault_credentials.txt"
              
              # Save credentials with proper formatting
              {
                echo "=== VAULT CREDENTIALS (Generated: $(date)) ==="
                echo ""
                echo "$INIT_OUTPUT"
                echo ""
                echo "=== IMPORTANT NOTES ==="
                echo "1. Keep these credentials secure and backed up"
                echo "2. You need 3 unseal keys to unseal the vault"
                echo "3. The root token is required for initial setup"
                echo ""
                echo "=== END OF CREDENTIALS ==="
              } > "$CREDS_FILE"
              
              # Secure the credentials file
              chmod 600 "$CREDS_FILE"
              
              echo "Credentials saved to: $CREDS_FILE"
            else
              echo "Vault is already initialized."
            fi

      - name: Unseal and Login to Vault
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DROPLET_IP }}
          username: deployuser
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            # Check if Vault is sealed
            SEAL_STATUS=$(docker exec $(docker ps -q -f name=vault) vault status -format=json | jq -r .sealed)
            
            if [ "$SEAL_STATUS" = "true" ]; then
              echo "Vault is sealed. Unsealing..."
              
              # Find the most recent credentials file
              CREDS_DIR="/home/deployuser/.vault"
              CREDS_FILE="$CREDS_DIR/vault_credentials.txt"
              
              if [ -f "$CREDS_FILE" ]; then
                echo "Using credentials from: $CREDS_FILE"
                
                # Extract the first 3 unseal keys and root token
                UNSEAL_KEY_1=$(grep "Unseal Key 1:" "$CREDS_FILE" | cut -d' ' -f4)
                UNSEAL_KEY_2=$(grep "Unseal Key 2:" "$CREDS_FILE" | cut -d' ' -f4)
                UNSEAL_KEY_3=$(grep "Unseal Key 3:" "$CREDS_FILE" | cut -d' ' -f4)
                ROOT_TOKEN=$(grep "Initial Root Token:" "$CREDS_FILE" | cut -d' ' -f4)
                
                # Unseal Vault with the three keys
                echo "Unsealing with key 1..."
                docker exec $(docker ps -q -f name=vault) vault operator unseal "$UNSEAL_KEY_1"
                echo "Unsealing with key 2..."
                docker exec $(docker ps -q -f name=vault) vault operator unseal "$UNSEAL_KEY_2"
                echo "Unsealing with key 3..."
                docker exec $(docker ps -q -f name=vault) vault operator unseal "$UNSEAL_KEY_3"
                
                # Login with root token
                echo "Logging in with root token..."
                docker exec $(docker ps -q -f name=vault) vault login "$ROOT_TOKEN"
                
                echo "Vault is now unsealed and logged in!"
              else
                echo "No credentials file found in $CREDS_DIR"
              fi
            else
              echo "Vault is already unsealed."
            fi

      - name: Populate Vault with Secrets
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DROPLET_IP }}
          username: deployuser
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            # Check if secrets file exists
            SECRETS_FILE="/home/deployuser/.vault/vault_secrets.vault"
            if [ -f "$SECRETS_FILE" ]; then
              echo "Found secrets file, populating Vault..."
              
              # Get root token from credentials file
              ROOT_TOKEN=$(grep "Initial Root Token:" /home/deployuser/.vault/vault_credentials.txt | cut -d' ' -f4)
              
              # Copy secrets file into Vault container
              VAULT_CONTAINER=$(docker ps -q -f name=vault)
              docker cp "$SECRETS_FILE" $VAULT_CONTAINER:/tmp/secrets.json
              
              # Enable KV secrets engine and populate secrets
              docker exec $VAULT_CONTAINER sh -c '
                # Install jq
                apk add --no-cache jq
                
                export VAULT_TOKEN="'$ROOT_TOKEN'"
                
                # Enable KV v2 secrets engine if not already enabled
                vault secrets enable -path=secret kv-v2 2>/dev/null || true
                
                echo "Reading new secrets from file..."
                cat /tmp/secrets.json
                
                # Transform new secrets to flat structure
                NEW_SECRETS=$(cat /tmp/secrets.json | jq -r "to_entries | map({key: .key, value: .value}) | from_entries")
                
                echo "Checking if new secrets are valid JSON..."
                if ! echo "$NEW_SECRETS" | jq "." > /dev/null 2>&1; then
                  echo "Error: New secrets are not valid JSON"
                  exit 1
                fi
                
                echo "Attempting to get existing secrets..."
                VAULT_RESPONSE=$(vault kv get -format=json secret/config 2>/dev/null || echo "{\"data\": {\"data\": {}}}")
                
                echo "Vault response:"
                echo "$VAULT_RESPONSE" | jq "."
                
                EXISTING_SECRETS=$(echo "$VAULT_RESPONSE" | jq -r ".data.data // {}")
                
                echo "Checking if existing secrets are valid JSON..."
                if ! echo "$EXISTING_SECRETS" | jq "." > /dev/null 2>&1; then
                  echo "Warning: No existing secrets or invalid JSON, using empty object"
                  EXISTING_SECRETS="{}"
                fi
                
                # Debug output
                echo "Existing secrets structure:"
                echo "$EXISTING_SECRETS" | jq "."
                echo "New secrets structure:"
                echo "$NEW_SECRETS" | jq "."
                
                # Merge secrets
                if [ "$EXISTING_SECRETS" = "{}" ]; then
                  echo "No existing secrets, using only new secrets"
                  MERGED_SECRETS="$NEW_SECRETS"
                else
                  echo "Merging existing and new secrets..."
                  MERGED_SECRETS=$(echo "$EXISTING_SECRETS" "$NEW_SECRETS" | jq -s ".[0] * .[1]")
                fi
                
                # Verify merged secrets are valid JSON
                if ! echo "$MERGED_SECRETS" | jq "." > /dev/null 2>&1; then
                  echo "Error: Merged secrets are not valid JSON"
                  exit 1
                fi
                
                # Debug merged output
                echo "Merged secrets structure:"
                echo "$MERGED_SECRETS" | jq "."
                
                # Save merged secrets to temporary file
                echo "$MERGED_SECRETS" > /tmp/merged_secrets.json
                
                echo "Contents of merged_secrets.json:"
                cat /tmp/merged_secrets.json
                
                # Load merged secrets into Vault
                vault kv put secret/config @/tmp/merged_secrets.json
                
                # Clean up
                rm /tmp/secrets.json /tmp/merged_secrets.json
                
                # Show what changed
                echo "Updated secrets in Vault. Current secrets (keys only):"
                vault kv get -format=json secret/config | jq -r ".data.data | keys[]"
              '
              
              echo "Vault secrets updated successfully!"
            else
              echo "No secrets file found at $SECRETS_FILE, skipping Vault population"
            fi

